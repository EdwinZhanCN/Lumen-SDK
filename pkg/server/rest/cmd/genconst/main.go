package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	input  = flag.String("input", "", "input Go source file containing interfaces")
	output = flag.String("output", "", "output Go file to write constants to")
)

func check(err error) {
	if err != nil {
		fmt.Fprintln(os.Stderr, "error:", err)
		os.Exit(2)
	}
}

// Get route key from method name: remove leading "Get", convert CamelCase -> snake_case
func methodToRouteKey(name string) string {
	name = strings.TrimPrefix(name, "Get")
	re := regexp.MustCompile("([a-z0-9])([A-Z])")
	s := re.ReplaceAllString(name, "${1}_${2}")
	return strings.ToLower(s)
}

// snake_case -> CamelCase
func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

func main() {
	flag.Parse()
	if *input == "" || *output == "" {
		fmt.Fprintln(os.Stderr, "must provide -input and -output")
		flag.Usage()
		os.Exit(2)
	}
	abs, err := filepath.Abs(*input)
	check(err)
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, abs, nil, parser.ParseComments)
	check(err)

	routeKeys := map[string]struct{}{}

	// Visit declarations to find interface methods
	for _, decl := range f.Decls {
		gd, ok := decl.(*ast.GenDecl)
		if !ok || gd.Tok != token.TYPE {
			continue
		}
		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if iface, ok := ts.Type.(*ast.InterfaceType); ok {
				for _, m := range iface.Methods.List {
					if len(m.Names) == 0 {
						// embedded interface - skip
						continue
					}
					methodName := m.Names[0].Name
					route := methodToRouteKey(methodName)
					if route == "" {
						continue
					}
					routeKeys[route] = struct{}{}
				}
			}
		}
	}

	// Build output
	outDir := filepath.Dir(*output)
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		check(err)
	}
	fout, err := os.Create(*output)
	check(err)
	defer fout.Close()

	fmt.Fprintln(fout, "// Code generated by genconst; DO NOT EDIT.")
	fmt.Fprintln(fout, "package rest")
	fmt.Fprintln(fout)
	fmt.Fprintln(fout, "const (")

	// deterministic order
	keys := make([]string, 0, len(routeKeys))
	for k := range routeKeys {
		keys = append(keys, k)
	}
	// sort for stable output
	sortStrings(keys)

	for _, route := range keys {
		constName := "Service" + snakeToCamel(route)
		fmt.Fprintf(fout, "\t%s = \"%s\"\n", constName, route)
	}
	fmt.Fprintln(fout, ")")
	fmt.Fprintln(fout)
	fmt.Fprintf(fout, "// Generated %d constants.\n", len(keys))
	fmt.Fprintln(fout)
	fmt.Fprintln(fout, "// NOTE: run `go generate ./pkg/server/rest/service` to update.")
}

func sortStrings(ss []string) {
	// simple insertion sort to avoid extra imports (keeps file simple)
	for i := 1; i < len(ss); i++ {
		j := i
		for j > 0 && ss[j-1] > ss[j] {
			ss[j-1], ss[j] = ss[j], ss[j-1]
			j--
		}
	}
}
